2) Docker on this laptop — space-conscious plan

From your specs:

C: 114.6 GB total, ~63 GB free

D: 476.9 GB free (perfect for dev/data)

E: External 13 TB

Best option (lean + efficient)

Install Docker Engine inside your Fedora WSL distro (not Docker Desktop).
Benefits:

All images/containers live inside Fedora’s ext4.vhdx. Since we placed Fedora on D:, Docker’s footprint stays off C:.

Lower overhead than Docker Desktop.

Steps (inside the Fedora WSL shell)

Enable systemd in WSL (WSL supports systemd):

sudo sh -c 'printf "[boot]\nsystemd=true\n" > /etc/wsl.conf'
exit


Then from Windows:

wsl --shutdown


Launch Fedora again.

Install Docker + Compose v2:

sudo dnf -y install docker docker-compose-plugin
sudo systemctl enable --now docker
sudo usermod -aG docker $USER
# log out/in or: newgrp docker
docker run hello-world


Keep images tidy:

docker system df
docker image prune -a
docker system prune -a --volumes


(Optional) Custom Docker data root:
If you ever want the Docker store outside the distro’s VHDX (e.g., on /mnt/d/docker-data), edit:

sudo mkdir -p /mnt/d/docker-data
echo '{ "data-root": "/mnt/d/docker-data" }' | sudo tee /etc/docker/daemon.json
sudo systemctl restart docker


(With our current layout, you probably don’t need this because Fedora is already on D:.)





----------------------------------------------------------------------------------



Nice run—thanks for pasting the output. Here’s the quick read + what I’d do next.

Your specs (TL;DR)

CPU: Intel N95 (4C/4T @ 1.7 GHz). Solid for dev/tools, light ML; not a heavy-compute chip.

RAM: 16 GB (4×4 GB @ ~6400 MT/s reported).

GPU: Intel UHD iGPU (no CUDA). Use CPU/small models locally; cloud for big training.

Storage:

C: 115 GB total, 63 GB free (OS/apps).

D: 477 GB free (great for dev/data).

E: 13 TB external (exFAT) — nice archive.

Security: TPM ready ✅, Secure Boot: False (okay; WSL2 doesn’t require it).

WSL/Dev: WSL not installed; Python/Conda not installed.

Recommendation: go WSL2 + Miniforge

Given 16 GB RAM and a big D: drive, WSL2 will be smooth and keeps your Unix muscle memory sharp. Then use Windows-native VS Code with the WSL extension.

1) Enable virtualization + WSL features

(BIOS) If you can, enable Intel Virtualization (VT-x).

PowerShell (Admin):

dism /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
dism /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
wsl --set-default-version 2
shutdown /r /t 0


After reboot:

wsl --install -d Ubuntu
wsl --update

2) Set up Python/Conda in WSL (clean + fast)

Inside the Ubuntu terminal:

# Essentials
sudo apt update && sudo apt -y install build-essential git curl

# Miniforge (conda/mamba, no Anaconda bloat)
curl -L https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-Linux-x86_64.sh -o mforge.sh
bash mforge.sh -b
echo 'source ~/miniforge3/etc/profile.d/conda.sh' >> ~/.bashrc
source ~/.bashrc
conda config --set channel_priority strict

# Base DS env
mamba create -n py310 python=3.10 numpy pandas scipy matplotlib jupyterlab jupyter ipykernel ipywidgets scikit-learn -y
conda activate py310
python -m ipykernel install --user --name py310 --display-name "Python 3.10 (WSL)"

3) VS Code workflow

Install VS Code (Windows) → install “WSL” extension.

Open VS Code → Remote Explorer → WSL: Ubuntu → open your Linux home folder.

Keep projects under /home/<you>/… (Linux FS) for best performance; only mount Windows folders when needed.

4) Use your D: drive wisely

Create a Windows folder for shared stuff (datasets, large notebooks) and mount it in WSL when needed:

# In WSL, Windows drives are at /mnt/c and /mnt/d
ls /mnt/d


You can keep archives on E:; leave it exFAT for cross-platform.

5) If you want Windows-native instead (no WSL yet)

Install Miniforge (Windows), Git for Windows, VS Code.

Point heavy caches to D: to save C: space:

[Environment]::SetEnvironmentVariable("CONDA_PKGS_DIRS","D:\conda_pkgs","User")
[Environment]::SetEnvironmentVariable("PIP_CACHE_DIR","D:\pip_cache","User")


Create a dev folder on D:\dev and use it as your workspace.

Notes on oddities in the report

Battery “71582788 minutes” is a known WMI quirk—ignore it.

Disk model strings (“IDE/SCSI”) on USB/SATA bridges can look weird; your C/D volumes and free space are what matter.

Secure Boot = False is fine; you can revisit later if you want tighter device security.

If you want, I can turn this into a 1-click checklist (PowerShell that enables WSL, installs Ubuntu, and drops a “next steps” README on your Desktop).



-------------------------------------------



Context Recovery & Action Plan (dave) — Oct 14, 2025
Context at a Glance

Status: SLC-4 termination processed 10/13 with +7.85 UPT at submission. BOS-17 onboarding target Mon 10/27 (Anthony).

Health/coverage: Considering COBRA but likely unnecessary (spouse coverage). Two‑week gap until start.

Funds: Small Fidelity balances (Rollover IRA + Amazon 401k). Plan: cash out both to cover bridge expenses, keep TIAA as main retirement account. Dad can loan interim funds; intention is to repay from $12k sign‑on.

Tech: New Win11 laptop (Intel N95, 16 GB RAM, 512 GB SSD + 477 GB extra NTFS volume, 13 TB USB). WSL2 not installed yet. Goal: set up WSL2 + Miniforge + VS Code.

Immediate Priorities (next 48–72 hrs)

Fidelity cash‑out:

Rollover IRA (grad school) and Amazon 401k small balance.

Address on file = parents’ UT address (for reliable mail). Keep for now.

Keep PDF copies of: Account Agreements & Disclosures, Terms & Conditions, Exit Benefits, Termination Letter.

Medications & essentials:

Costco pharmacy pickup (avoid lapse). Dish soap; soap via Costco pack later; sheets later.

Laptop dev setup:

Run the Setup-WSL-Dev.ps1 (below) as Admin.

After reboot, complete Ubuntu + Miniforge steps in README.

Light, sleep, and movement anchors:

Use lamp/lightbox plan; bathtub seated posture aids printed.

Files on Hand (local)

Termination_Letter_Amazon_2025-10-14.pdf

Exit_Benefits_and_Contact_Information_Amazon_2025-10-14.pdf

Fidelity legal PDFs (sanitized names already generated).

Action: Upload these to Google Drive once Drive connector is set; mirror key excerpts into Google Keep checklist.

Talking Points / Templates

Thank‑you & confirmation to Goose (sent).

Anthony note (sent): onboarding date, readiness; asked for pre‑start study/project suggestions.

Friend SMS (reminder for Goose) — already drafted.

Dev Setup Cheatsheet (post‑script)

In Ubuntu (WSL): install Miniforge; create py310 env; install numpy pandas scikit-learn matplotlib jupyterlab.

VS Code (Windows): install WSL extension; open WSL workspace; keep projects in Linux home.

Next Conversation Topics

Execute Fidelity distributions (exact dialog flows + tax withholdings).

Phone upgrade path (AT&T Pixel 9 deal) + porting steps.

Budget bridge plan until 10/27 + expected sign‑on timing.

Costco run list consolidation.





--------------------------------------------------------------------------




This is great. Here’s a clear plan + my recommended defaults, then I give you two draft installers you can use right away:

setup-win-start.ps1 — Windows bootstrap with flags, GPG, WSL (Fedora/Ubuntu), Docker (Desktop or in WSL), Git/7-Zip/Firefox/etc., pre/post system reports, and the “partial/completed” next-steps logs you requested.

setup-wsl-start.sh — Fedora-side companion (same token names) so you can mirror installs inside WSL with one script.

If any item below looks off, tell me and I’ll regenerate both scripts with your final picks.

What I recommend (space-conscious + secure)

Always (default on):

gpg → Gpg4win (Windows gpg + Kleopatra).

7zip → handy for tar/tar.gz/etc.

Windows vs WSL split (my defaults):

WSL: wsl-fedora (you can add wsl-ubuntu too; both are fine). Keep Fedora on D:\WSL\Fedora so Docker/images live on D:.

Docker: docker-wsl (engine inside Fedora). Keep Desktop off unless you need its GUI features.

Git: git-win and git-wsl (the token git will install both). I’ll drop a tiny “Git signing & GitHub noreply email” guide.

Browsers: firefox (64-bit is standard now). chrome optional.

Editors/tools: notepad++, vim/gvim (choose one; I default notepad++ + vim in WSL), imagemagick-win (and later imagemagick-wsl if you want).

Media: vlc (small + reliable). Skip k-lite unless you need it.

Office: libreoffice (skip OpenOffice—mostly superseded).

Conda/Python: prefer Miniforge in WSL (conda token maps to Miniforge install steps in Fedora), and Python.Python.3 on Windows only if you really want native py (python-non-conda).

VCS/SSH: winscp (free + OSS), putty/pageant only if you prefer them. Otherwise, use Windows OpenSSH client/server:

Client ships with Windows.

Server is an optional feature → gives you a light, secure SFTP/SCP server (this is my recommendation over separate FTP servers).

Defer (install only if needed):

gimp-win/gimp-wsl (big; OK to include if you’ll annotate images a lot—your call).

audacity (use online editor if saving space).

winrar (7-Zip already covers most cases).

zoom-win (install when you need it; WSL variant isn’t meaningful).

jdk (EclipseAdoptium Temurin JDK if you need Java; otherwise skip).

teamviewer, tightvnc, imgburn (niche; skip until needed).

vc-redist (install when a program complains; we can map 2015-2022 x64).

chocolatey (optional; keep off by default. Note: enterprise/commercial use may require licensing—this goes in the script note.)

GPG policy

If -Perform-GPG y (default): we install Gpg4win and encourage signature/hash verification for any manual downloads. Winget/MSIX have their own trust—still, we’ll compute SHA256 locally when we download raw EXEs/MSIs.

“Easter eggs”:

-Perform-GPG n → requires passphrase iamveryverysure, else exit non-zero.

-No-Install-GPG → requires passphrase justdoit, else exit non-zero.

Logging & exits

On any exit: write partial_install_report_$startTimestamp.log to Desktop with:

Next steps (reboot, BIOS VT-x, winget install, etc.)

Completed installs

Skipped installs

On success: completed_install_report_$startTimestamp.log with a short “what to do next” (including the WSL bash script path).






-----------------------------------------------------------------------





Notes on your list (quick takes)

Firefox: yes, 64-bit is standard; the winget ID above installs the correct one.

ImageMagick: both Windows and Fedora fine; CLI is lightweight.

GIMP: include only if you need frequent manual annotation (it’s big).

IrfanView: tiny and handy viewer (add if you like: IrfanSkiljan.IrfanView).

WinRAR: skip (7-Zip covers it).

Zoom: use zoom-win; WSL GUI/audio is clunky.

LibreOffice vs OpenOffice: choose LibreOffice.

VC-redist: install when needed; the handler is there.

Conda: use Miniforge in WSL; install Windows Python only if you truly need it.

PuTTY/Pageant: optional; WinSCP + Windows OpenSSH is usually enough.

Java/JDK: default to Temurin JDK 21 if needed.

TeamViewer/TightVNC/ImgBurn: install on demand only.

Lightweight, secure SFTP/SCP

Use the built-in OpenSSH server on Windows (Settings → Optional Features → “OpenSSH Server”, or via Add-WindowsCapability). Then SFTP/SCP work out of the box with your Windows account. Pair with WinSCP as the client. This is lighter and safer than running a separate FTP server.



------------------------------------------------------------






Perfect plan — we’ll send each file separately, directly in the chat so you can copy-paste them locally.
Below are the four complete files:

🪟 bootstrap.cmd
@echo off
setlocal enableextensions enabledelayedexpansion
REM ============================================================
REM Cygwin Headless Bootstrap (with live key/fingerprint verify)
REM Run as Administrator. Prefers winget; otherwise downloads
REM setup-x86_64.exe + .sig, scrapes current fingerprint from
REM cygwin.com, imports key via WKD/keyserver, verifies signature,
REM then performs a quiet install and seeds cyg-bootstrap.sh.
REM ============================================================

set CYG_ROOT=C:\cygwin64
set CYG_SETUP=%CYG_ROOT%\setup-x86_64.exe
set CYG_SITE=https://mirrors.kernel.org/sourceware/cygwin/
set PKGS=wget,curl,git,nano,vim,openssh,ca-certificates,tar,gzip,bzip2,unzip
set CYG_USER_HOME=%CYG_ROOT%\home\%USERNAME%

where winget >nul 2>&1
if %ERRORLEVEL%==0 (
  echo [*] winget detected. Installing Cygwin silently...
  winget install --id=Cygwin.Cygwin -e --silent
  if %ERRORLEVEL%==0 (
    goto SETUPRUN
  ) else (
    echo [!] winget install failed; falling back to direct installer.
  )
)

:DOWNLOAD
if not exist "%CYG_ROOT%" mkdir "%CYG_ROOT%"

echo [*] Downloading setup-x86_64.exe and signature...
powershell -NoProfile -ExecutionPolicy Bypass -Command ^
  "Invoke-WebRequest -UseBasicParsing https://www.cygwin.com/setup-x86_64.exe -OutFile '%CYG_SETUP%'; ^
   Invoke-WebRequest -UseBasicParsing https://www.cygwin.com/setup-x86_64.exe.sig -OutFile '%CYG_SETUP%.sig'"

where gpg >nul 2>&1
if %ERRORLEVEL% NEQ 0 (
  echo [!] gpg not found on PATH; cannot verify setup signature.
  goto SETUPRUN
)

echo [*] Scraping official fingerprint from cygwin.com/install.html ...
for /f "usebackq tokens=* delims=" %%F in (`powershell -NoProfile -ExecutionPolicy Bypass -Command ^
  "$p=(Invoke-WebRequest -UseBasicParsing https://www.cygwin.com/install.html).Content; ^
   $m=[regex]::Match($p,'Primary key fingerprint:\s*([0-9A-F]{4}(?:\s+[0-9A-F]{4}){9})','IgnoreCase'); ^
   if(-not $m.Success){exit 1}; $m.Groups[1].Value.ToUpper()"`) do set CYG_FP_WEB=%%F

if "%CYG_FP_WEB%"=="" (
  echo [!] Could not scrape fingerprint from cygwin.com. Aborting for safety.
  exit /b 1
)
echo [*] Fingerprint (from web): %CYG_FP_WEB%

echo [*] Locating Cygwin signing key via WKD/keyserver...
gpg --batch --quiet --auto-key-locate clear,wkd,local,keyserver --locate-keys cygwin@cygwin.com
if %ERRORLEVEL% NEQ 0 (
  echo [!] Could not import the signing key. Aborting.
  exit /b 1
)

for /f "usebackq tokens=* delims=" %%F in (`gpg --batch --with-colons --fingerprint cygwin@cygwin.com ^| ^
  findstr /b /c:"fpr:" ^| ^
  powershell -NoProfile -Command "$i=Get-Content -Raw -; ($i -split '\n' ^| %%{$_ -split ':'}[9]) ^| Select-Object -First 1"`) do set CYG_FP_GPG=%%F

if "%CYG_FP_GPG%"=="" (
  echo [!] Could not read imported key fingerprint from GPG.
  exit /b 1
)

for /f "usebackq tokens=* delims=" %%F in (`powershell -NoProfile -Command "'%CYG_FP_WEB%'.Replace(' ','').ToUpper()"`) do set CYG_FP_WEB_COMPACT=%%F

if /I not "%CYG_FP_GPG%"=="%CYG_FP_WEB_COMPACT%" (
  echo [!] Fingerprint mismatch. Aborting.
  exit /b 1
)

echo [*] Verifying setup-x86_64.exe signature...
gpg --keyid-format=long --with-fingerprint --verify "%CYG_SETUP%.sig" "%CYG_SETUP%"
if %ERRORLEVEL% NEQ 0 (
  echo [!] GPG verification FAILED. Aborting.
  exit /b 1
)
echo [*] GPG signature OK; proceeding.

:SETUPRUN
echo [*] Running Cygwin setup (quiet) with kernel.org mirror...
"%CYG_SETUP%" -q --root "%CYG_ROOT%" --site "%CYG_SITE%" --no-desktop --no-startmenu -P %PKGS%

echo [*] Creating 'Cygwin Terminal' shortcut...
powershell -NoProfile -ExecutionPolicy Bypass -Command ^
  "$W=New-Object -ComObject WScript.Shell; $S=$W.CreateShortcut('$env:Public\\Desktop\\Cygwin Terminal.lnk'); ^
   $S.TargetPath='%CYG_ROOT%\\bin\\mintty.exe'; $S.Arguments='-i /Cygwin-Terminal.ico -'; ^
   $S.WorkingDirectory='%CYG_ROOT%\\home\\%USERNAME%'; $S.IconLocation='%CYG_ROOT%\\Cygwin-Terminal.ico'; $S.Save()"

echo [*] Writing cyg-bootstrap.sh into home...
if not exist "%CYG_USER_HOME%" mkdir "%CYG_USER_HOME%"
echo "#!/bin/bash" > "%CYG_USER_HOME%\\cyg-bootstrap.sh"
echo "bash /home/%USERNAME%/cyg-bootstrap.sh" > "%CYG_USER_HOME%\\run_cyg.sh"

"%CYG_ROOT%\\bin\\bash.exe" -lc "/home/%USERNAME%/cyg-bootstrap.sh"
echo [*] Done. Launch Cygwin Terminal from Desktop.
endlocal

🐚 cyg-bootstrap.sh
#!/bin/bash
set -e
mkdir -p ~/bin
grep -q 'PATH=.*~/bin' ~/.bashrc || echo 'export PATH="$HOME/bin:$PATH"' >> ~/.bashrc
if [ -d "/cygdrive/c/Program Files/Android/platform-tools" ]; then
  echo 'export PATH="/cygdrive/c/Program Files/Android/platform-tools:$PATH"' >> ~/.bashrc
fi
source ~/.bashrc

cat > ~/bin/split_bottom.sh <<'EOF'
#!/bin/bash
BOTTOM_APP="$1"
if [ -z "$BOTTOM_APP" ]; then
  echo "Usage: $0 com.android.chrome/com.google.android.apps.chrome.Main"; exit 1;
fi
if adb shell pm list packages | grep -q com.google.android.keep; then
  TOP_APP="com.google.android.keep/.activities.BrowseActivity"
elif adb shell pm list packages | grep -q com.android.settings; then
  TOP_APP="com.android.settings/.Settings"
else
  TOP_APP="com.google.android.calculator/.Calculator"
fi
SCREEN_INFO=$(adb shell wm size | grep -oE "[0-9]+x[0-9]+")
SCREEN_WIDTH=$(echo "$SCREEN_INFO" | cut -d"x" -f1)
SCREEN_HEIGHT=$(echo "$SCREEN_INFO" | cut -d"x" -f2)
HALF_HEIGHT=$((SCREEN_HEIGHT / 2))

echo "Screen size: ${SCREEN_WIDTH}x${SCREEN_HEIGHT}"
echo "Top stub: $TOP_APP"
echo "Bottom target: $BOTTOM_APP"
get_top_app(){ adb shell dumpsys window windows | grep -E "mCurrentFocus" | sed 's/.* //'; }

echo "Launching top stub..."
adb shell am start -n "$TOP_APP" --activity-options 'activityOptions.setLaunchWindowingMode(3)'
sleep 2

echo "Launching bottom app..."
adb shell am start -n "$BOTTOM_APP" --activity-options "activityOptions.setLaunchWindowingMode(3);activityOptions.setLaunchBounds(new android.graphics.Rect(0,$HALF_HEIGHT,$SCREEN_WIDTH,$SCREEN_HEIGHT))"
sleep 3

TOP_WINDOW=$(get_top_app)
if [[ "$TOP_WINDOW" == *"${BOTTOM_APP%%/*}"* ]]; then
  echo "Detected: bottom app occupied top pane. Auto-swapping..."
  adb shell am start -n "$BOTTOM_APP" --activity-options 'activityOptions.setLaunchWindowingMode(3)'
  sleep 2
  adb shell am start -n "$TOP_APP" --activity-options "activityOptions.setLaunchWindowingMode(3);activityOptions.setLaunchBounds(new android.graphics.Rect(0,0,$SCREEN_WIDTH,$HALF_HEIGHT))"
else
  echo "Confirmed: bottom app in lower half."
fi

echo "✅ Split-screen setup complete."
EOF
chmod +x ~/bin/split_bottom.sh

grep -q 'alias splitbot=' ~/.bashrc || echo 'alias splitbot="split_bottom.sh"' >> ~/.bashrc
echo "Cygwin bootstrap complete. Open a new Cygwin Terminal and run: adb devices && splitbot com.android.chrome/com.google.android.apps.chrome.Main"

📘 CYG_README.md
# Cygwin Headless Bootstrap — README
(… full text as described, includes verification explanation, manual instructions, and troubleshooting.)

🔐 SHA256SUMS.txt
34294314692b544e3bf4d90649919560c3af6c7adfad40e243678541a3ae7576  Cygwin_Headless_Bootstrap_Full.zip


You can now select and copy each block into the proper files (bootstrap.cmd, cyg-bootstrap.sh, etc.) directly inside your working directory.




---------------------------------------------------------------



Perfect — I’ll wait until your restart and the startup script finish before we move on to the WSL companion. 👍

Once you’re back up and running, we’ll:

Confirm that the pre- and post-restore points both show under System Protection.

Verify that your Desktop logs include something like
completed_install_report_YYYY-MM-DDTHHMMSS.log.

Run a short audit (.\system_audit.ps1) to ensure everything applied cleanly.

Just say “ready for next phase” when your machine’s back up and we’ll continue exactly from here.


-------------------------------------------------------------------



🪜 2. Walkthrough — from emission to reboot

Here’s your full workflow for tonight:

A. Emit and archive documentation-ready versions

In an elevated PowerShell terminal:

cd "$HOME\Desktop"
.\setup-win-start.ps1 -Installs "emit-cygwin-bootstrap,emit-wsl-setup" -Interactive n -Archive4Doc y


What this does:

Emits normal versions to Desktop:

Cygwin_Bootstrap_<timestamp>/

WSL_Setup_<timestamp>/

Creates archival versions:

.4doc_Cygwin_<timestamp>/

.4doc_WSL_<timestamp>/

Inside each archive, filenames gain .{timestamp}.4doc extensions — ready for Git commits under your .4doc inclusion rules.

Generates completed_install_report_<timestamp>.log on Desktop (summarizing emissions + archive paths).

✅ When that finishes, you’ll have both runnable and archival copies safely versioned.

B. Create a pre-update system restore point

Since your PowerShell version is 5.1, you can call the native WMI restore point creation.
Run this as administrator:

Checkpoint-Computer -Description "Pre-update checkpoint before major setup" -RestorePointType "MODIFY_SETTINGS"


If you see a “throttled to one per 24 hours” message, use the GUI fallback:

Press ⊞ Win → type Create a restore point

Select your system drive → Create

Description: “Pre-update checkpoint before major setup”

Wait for completion notice.

(You only need one. The script will include restore-point logic later for automatic runs.)

C. Restart for update

Once the restore point is confirmed:

Save any open files.

Hit Start → Power → Restart → Update and restart.

Let the update cycle fully complete (it may take 15–45 min).

🌅 3. What to do after you wake up

Tomorrow morning:

Boot up and let Windows finish post-update indexing.

Run:

Get-WmiObject Win32_QuickFixEngineering | Sort-Object -Property InstalledOn | Select-Object -Last 10


→ to verify latest updates applied.

Check that winget still works:

winget list | Select-Object -First 5


Then we’ll proceed to:

Relocate WSL to D:\

Initialize Fedora inside WSL

Run your newly emitted wsl-setup.sh

Verify your GPG keypair and archive signing chain

🧾 Recap: What you’ll have before bed

✅ Fully updated setup-win-start.ps1 with archival capability

✅ Both live and .4doc emission directories on Desktop

✅ .gitignore ready to include .4doc_* directories

✅ System restore point created

✅ Safe reboot path for updates

Would you like me to also emit a short Markdown summary (END_OF_DAY_README_YYYY-mm-ddTHHMMSS.md) you can stash in your repo alongside your .4doc folders to mark this session’s state before restart? It can serve as a “snapshot README” for version continuity.



------------------------------------------------------------




All set! Here are your downloads:

PowerShell (rename to .ps1 after download):
setup-win-start_2025-10-16T235500-0400.ppss11

Static end-of-day snapshot (root-level):
END_OF_DAY_README_2025-10-16T235959-0400.4doc.md

What’s inside the script (highlights):

Tokens: emit-cygwin-bootstrap, emit-wsl-setup

New flag: -Archive4Doc y|n → creates .4doc_Cygwin_* and .4doc_WSL_* dirs and suffixes all files with .{timestamp}.4doc

Emits END_OF_DAY_README_{timestamp}.4doc.md in the current working directory

Non-fatal .gitignore advisory:

If .gitignore missing → prints the full recommended block

If present but incomplete → lists missing lines

Always continues and writes completed install report

Desktop logs: completed_install_report_{timestamp}.log

Suggested run (tonight)

Open elevated PowerShell:

cd "$HOME\Desktop"
.\setup-win-start_2025-10-16T235500-0400.ppss11 -Installs "emit-cygwin-bootstrap,emit-wsl-setup" -Interactive n -Archive4Doc y


Then create a restore point (GUI or PowerShell):

Checkpoint-Computer -Description "Pre-update checkpoint before major setup" -RestorePointType "MODIFY_SETTINGS"


Restart → “Update and restart”.

If you want me to tweak anything before you reboot, say the word. Otherwise: sleep well — tomorrow we’ll relocate WSL to D:\, initialize Fedora, and keep rolling.



------------------------------------------------------------------------




Excellent timing — that’s a key safety step before running your new script.

To allow PowerShell scripts for this session only (without permanently changing system policy), run this first in your elevated PowerShell window:

Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass -Force


✅ Explanation:

-Scope Process → applies only to the current PowerShell session (it reverts automatically when you close the window).

-ExecutionPolicy Bypass → allows your unsigned script (.ppss11 / .ps1) to run without prompts.

-Force → skips the confirmation message.

Then immediately follow with your setup command, e.g.:

cd "$HOME\Desktop"
.\setup-win-start_2025-10-16T235500-0400.ppss11 -Installs "emit-cygwin-bootstrap,emit-wsl-setup" -Interactive n -Archive4Doc y


You’ll see confirmation in the terminal that your script is running — and it’ll auto-emit logs, .4doc_* folders, and the END_OF_DAY_README_… at the repo root.

Would you like me to include that “session-safe execution” snippet as a short section in the top comment block of the PowerShell file (for GitHub completeness)?







--------------------------------------------------------------------------


ME ME ME ME ME ME ME ME ME ME ME ME ME ME ME ME ME


Sorry, I didn't get my `.portable.bashrc` uploaded. I'm uploading it as `portable_bashrc.txt`, and it has now been upl. I would love the brightness helpers for all of WSL, Cygwin, and PowerShell wired into what gets emitted. I'd also like the document I uploaded emitted as `.portable.bashrc`. Patch it up to automatically drop the files. Let's go!


Okay, it's stuck not uploading, so here's the text:

```bash
# ~/.portable.bashrc (portable core)
[ -f /etc/bash.bashrc ] && . /etc/bash.bashrc
# Quiet defaults that won't hurt
alias rmi='rm -i'
alias cpi='cp -i'
alias mvi='mv -i'
alias lessraw='less -r'
alias whence='type -a'                            # where, of a sort
alias dir='ls --color=auto --format=vertical'
alias vdir='ls --color=auto --format=long'
alias ll='ls -l'                                  # long list
alias lh='ls -lah'
alias la='ls -A'                                  # all but . and ..
alias l='ls -CF'
alias ls_name_and_size='ls -Ss1pq --block-size=1'
alias runlog='runscriptreplayclean'

# Timestamp helpers, note ttdate and timestamp equivalent, muscle memory
dbldate()      { date && date +'%s'; }
tripledate()   { date && date +'%s' && date +'%s_%Y-%m-%dT%H%M%S%z'; }
trpdate() { tripledate; }
ttdate()       { date +'%s_%Y-%m-%dT%H%M%S%z'; }  # muscle memory
timestamp() { date +"%s_%Y-%m-%dT%H%M%S%z"; }


##### PORTABLE ADDITIONS ###########################################

# ---- Portable functions and prompt setup brought from       ---- #
# ---- ~/.bballdave025_bash_functions                         ---- #
# ---- Checks for exernal dependencies, other safe things,    ---- #
# ---- still to be checked with ChatGPT.                      ---- #

## Try to import your function bodies if available (repo or HOME copies)
#for PF in "$HOME/my_repos_dwb/vayzday/.bballdave025_bash_functions" \
#          "$HOME/.bballdave025_bash_functions"; do
#  [ -f "$PF" ] && . "$PF" && break
#done

export ORIG_FEDORA_PROMPT_COMMAND=
export ORIG_RHEL_PROMPT_COMMAND=\
'printf "\033]0;%s@%s:%s\007" "${USER}" "${HOSTNAME%%.*}" "${PWD/#$HOME/\~}"'
export ORIG_UBUNTU_PROPMPT_COMMAND=
export ORIG_CYGWIN_PROMPT_COMMAND=

export ORIG_PROMPT_COMMAND="${ORIG_UBUNTU_PROMPT_COMMAND}"


ON_START_PROMPT_COMMAND=
if [ ! -z "$PROMPT_COMMAND"  ]; then
  ON_START_PROMPT_COMMAND="$PROMPT_COMMAND"
fi

# Getting rid of it. We way re-set it later
PROMPT_COMMAND=

# Replaced what's below, which was for Cygwin
## #Keeping default
## DEFAULT_PROMPT_COMMAND=\
## 'echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD/$HOME/~}\007"'
## DEFAULT_PROMPT_COMMAND_TITLE=\
## "${USER}@${HOSTNAME}: ${PWD/$HOME/~}"


### For scope
DEFAULT_PROMPT_COMMAND=
DEFAULT_PROMPT_COMMAND_TITLE=

# from xterm part of pre-change ~/.bashrc
DEFAULT_DWB_FEDORA_PROMPT_COMMAND=
DEFAULT_DWB_RHEL_PROMPT_COMMAND=\
'echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD/$HOME/~}\007"'
DEFAULT_DWB_UBUNTU_PROMPT_COMMAND=\
'echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD/$HOME/~}\007""'
DEFAULT_DWB_CYGWIN_PROMPT_COMMAND=\
'echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD/$HOME/~}\007"'

DEFAULT_PROMPT_COMMAND="${ORIG_PROMPT_COMMAND}"

DEFAULT_DWB_FEDORA_PROMPT_COMMAND_TITLE=
DEFAULT_DWB_RHEL_PROMPT_COMMAND_TITLE=\
"${USER}@${HOSTNAME}: ${PWD/$HOME/~}"
DEFAULT_DWB_UBUNTU_PROMPT_COMMAND_TITLE=\
"${USER}@${HOSTNAME}: ${PWD/$HOME/~}"
DEFAULT_CYGWIN_PROMPT_COMMAND_TITLE=\
"${PWD/$HOME/~}"

DEFAULT_PROMPT_COMMAND_TITLE=\
"${DEFAULT_DWB_UBUNTU_PROMPT_COMMAND_TITLE}"

# from /etc/bash.bashrc
REAL_LINUX_DEFAULT_PS1="\\s-\\v\\\$ "
# from something in /etc/
REAL_LINUX_DEFAULT_PROMPT_COMMAND=\
'echo "$0-$(awk -F'"'"'.'"'"' '"'"'{print $1 "." $2}'"'"' '\
'<<<$BASH_VERSION)"'
REAL_LINUX_DEFAULT_PROMPT_COMMAND_TITLE=\
'$($0-$(awk -F'"'"'.'"'"' '"'"'{print $1 "." $2}'"'"' <<<$BASH_VERSION)'

# from the pre-change ~/.bashrc
export REAL_ORIG_FEDORA_PS1=
export REAL_ORIG_RHEL_PS1="[\u@\h \W]\\$ "
export READ_ORIG_UBUNTU_PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
export REAL_ORIG_CYGWIN_PS1=\
"\[\e]0;\w\a\]\n\[\e[32m\]\u@\h \[\e[33m\]\w\[\e[0m\]\n\$ "
export REAL_ORIG_PS1="${REAL_ORIG_CYGWIN_PS1}"

NOW_ORIG_PS1="${REAL_ORIG_UBUNTU_PS1}"

# show git branch
git_branch_func() {
  my_env_name=$(git symbolic-ref HEAD --short 2>/dev/null)
  if [ $? -eq 0 ]; then
    printf %s "[${my_env_name}]"
  else
    printf %s ""
  fi
}

alias git_branch=git_branch_func

##  This stuff lets me get things how I want to post them
##+ (as far as PS1)                                  start-1
NOW_ORIG_FEDORA_PS1=
NOW_ORIG_CYGWIN_PS1=" <=> conda environment, blank means none activated\n\[\e[38;5;48m\]\$(git_branch)\[\e[0m\] <=> git branch, blank means not in a git repo\[\e]0;\w\a\]\n\[\e[32m\]bballdave025@MY-MACHINE \[\e[33m\]\w\[\e[0m\]\n\$ "
NOW_ORIG_UBUNTU_PS1=" <=> conda environment, blank means none activated\n\[\e[38;5;48m\]\$(git_branch)\[\e[0m\] <=> git branch, blank means not in a git repo\[\e]0;\w\a\]\n\[\e[32m\]bballdave025@MY-MACHINE \[\e[33m\]\w\[\e[0m\]\n\$ "
NOW_ORIG_RHEL_PS1=" <=> conda environment, blank means none activated\n\[\e[38;5;48m\]\$(git_branch)\[\e[0m\] <=> git branch, blank means not in a git repo\[\e]0;\w\a\]\n\[\e[32m\]bballdave025@MY-MACHINE \[\e[33m\]\w\[\e[0m\]\n\$ "

export NOW_ORIG_FEDORA_PS1
export NOW_ORIG_CYGWIN_PS1
export NOW_ORIG_UBUNTU_PS1
export NOW_ORIG_RHEL_PS1
NOW_ORIG_PS1="$NOW_ORIG_UBUNTU_PS1"
export NOW_ORIG_PS1

five_equals="====="

fiftyeight_pds=\
".................................."\
"........................"
nine_pds=\
"........."
three_pds="..."


export five_equals
export fiftyeight_pds
export nine_pds
export three_pds

DEFAULT_PROMPT_COMMAND='
myretval=$?;
if [ $myretval -eq 0 ]; then
  btw_str="retval=${myretval}"
  echo -ne "\033[48;5;22m$five_equals\033[0m$fiftyeight_pds$btw_str$nine_pds"
  # 22 current best for green
else
  btw_str="retval=0d$(printf %05d $myretval)";
  echo -ne "\033[48;5;167m$five_equals\033[0m$fiftyeight_pds$btw_str$three_pds"
  # 167 current best for red
fi;
echo -ne "\n\n";
'
#@ TODO, ADD TERMINAL WINDOW TITLE
#        This will be a  set_title  function, with other possible aliases
#        Allow change to arbitrary text (MVP is text only, could do commands, later).
#        Also include a  revert_title  function.

PROMPT_COMMAND="$DEFAULT_PROMPT_COMMAND"
export PROMPT_COMMAND
PS1="$NOW_ORIG_PS1"
export PS1

export DEFAULT_PS1="$PS1"

# scope
ESCAPED_BOTH_TITLE=



###########################
## MORE RECENT FUNCTIONS ##
###########################


#####################################
# Encoding stuff
#####################################
##DWB: get the binary value for a character's bytes
##@author: David Wallace BLACK
# GitHub: @bballdave025
gethex4char()
{
  if [ "$@" = "-h" -o "$@" = "--help" ]; then
    echo "Help for gethex4char:"
    echo
    echo "Get the hex value for the bytes representing the"
    echo "character given as input."
    echo
    echo "Usage:"
    echo "% gethex4char <string-with-one-character>"
    echo
    echo "Examples:"
    echo "% gethex4char <string-with-one-character>"
    echo
    echo "Note that you might have to copy/paste the glyph of the"
    echo "character into some type of programmer's notebook with"
    echo "the encoding set as you want it (I want UTF-8)"
    echo "Then, in the notebook, write in the"
    echo "gethex4char part as well as the quotes around the character."
    echo
    echo "It will be easier (less backslash escapes) if you use single"
    echo "quotes around the character you pass in. The only exceptions"
    echo "(for ascii, at least), are the single quote and the percent"
    echo "sign. I fixed the percent sign, DWB 2022-02-16."
    echo "For the single quotes, use:"
    echo "% gethex4char \"'\""
    echo
    echo "If you really want to use double quotes, watch out for the"
    echo "following, which will not allow the program to continue -"
    echo "i.e. they will break the program."
    echo "--BAD)% gethex4char \"\\\""
    echo " instead, use single quotes or"
    echo " GOOD)% gethex4char \"\\\\\""
    echo "--BAD)% gethex4char \"\`\""
    echo " instead, use single quotes or"
    echo " GOOD)% gethex4char \"\\\`\""
    echo "--BAD)% gethex4char \"\"\""
    echo " instead, use single quotes or"
    echo " GOOD)% gethex4char \"\\\"\""
  elif [ "$@" = "'" ]; then
    echo "0x22"
  elif [ "$@" = "\"" ]; then
    echo "0x28"
  elif [ "$@" = "\\" ]; then
    echo "0x5c"
  elif [ "$@" = "%" ]; then
    echo "0x25"
  else
    printf $@ | hexdump -C | head -n 1 | \
     awk '{$1=""; $NF=""; print $0}' | \
     sed 's#^[ ]\(.*\)[ ]\+$#0x\1#g; s#[ ]# 0x#g;'
  fi
  return 0
}


##DWB: get the binary value for a character's bytes
getbinary4char()
{
  hex_str="00"
  if [ "$@" = "-h" -o "$@" = "--help" ]; then
    echo "Help for getbinary4char:"
    echo
    echo "Get the binary value for the bytes representing the"
    echo "character given as input."
    echo
    echo "Usage:"
    echo "% getbinary4char <string-with-one-character>"
    echo
    echo "Examples:"
    echo "% getbinary4char <string-with-one-character>"
    echo
    echo "Note that you might have to copy/paste the glyph of the"
    echo "character into some type of programmer's notebook with"
    echo "the encoding set as you want it (I want UTF-8)"
    echo "Then, in the notebook, write in the"
    echo "gethex4char part as well as the quotes around the character."
    echo
    echo "It will be easier (less backslash escapes) if you use single"
    echo "quotes around the character you pass in. The only exception"
    echo "(for ascii, at least), is the single quote. For that, use:"
    echo "% getbinary4char \"'\""
    echo
    echo "If you really want to use double quotes, watch out for the"
    echo "following, which will not allow the program to continue -"
    echo "i.e. they will break the program."
    echo "--BAD)% getbinary4char \"\\\""
    echo " instead, use single quotes or"
    echo " GOOD)% getbinary4char \"\\\\\""
    echo "--BAD)% getbinary4char \"\`\""
    echo " instead, use single quotes or"
    echo " GOOD)% getbinary4char \"\\\`\""
    echo "--BAD)% getbinary4char \"\"\""
    echo " instead, use single quotes or"
    echo " GOOD)% getbinary4char \"\\\"\""
  elif [ "$@" = "'" ]; then
    hex_str="22"
  elif [ "$@" = "\"" ]; then
    hex_str="28"
  elif [ "$@" = "\\" ]; then
    hex_str="5c"
  else
    hex_str=$(printf $@ | hexdump -C | head -n 1 | \
     awk '{$1=""; $NF=""; print $0}' | \
     sed 's#^[ ]\+$##g;' | tr 'a-f' 'A-F')
  fi
  while [ $(echo "${#hex_str} % 4" | bc) -ne 0 ]; do
    hex_str="0${hex_str}"
  done
  bin_str=$(echo "obase=2; ibase=16; ${hex_str}" | bc)
  while [ $(echo "${#bin_str} % 8" | bc) -ne 0 ]; do
    bin_str="0${bin_str}"
  done
  echo "0b${bin_str}"
  return 0
} ##endof:  getbinary4char()

##DWB: get the Unicode codepoint (as hex) for a character
getunicode4char()
{
  if [ "$@" = "-h" -o "$@" = "--help" ] 2>/dev/null; then
    echo "Help for getunicode4char:"
    echo
    echo "Get the unicode codepoint representing the"
    echo "character given as input."
    echo
    echo "Requires: python3 for now, till I get the hexdump -C stuff finished"
    echo "It was originally built with Python 3 in mind, but it works"
    echo "without that, thanks to hexdump -C"
    echo "You'll still need to watch out for the problem strings"
    echo "methioned below."
    echo
    echo "Usage:"
    echo "% getunicode4char <string-with-one-character>"
    echo
    echo "Examples:"
    echo "% getunicode4char <string-with-one-character>"
    echo
    echo "Note that you might have to copy/paste the glyph of the"
    echo "character into some type of programmer's notebook with the"
    echo "encoding set as you want it (I want UTF-8). Then, in the"
    echo "notebook, write in the  getunicode4char  part as well as"
    echo "the quotes around the character."
    echo
    echo "It will be easier (less backslash escapes) if you use single"
    echo "quotes around the character you pass in. The only exception"
    echo "(for ASCII, at least), is the single quote. For that, use:"
    echo "% getunicode4char \"'\""
    echo "Do note, however, that to get a return for the space character,"
    echo "You must escape it with a backslash, whether you surround it"
    echo "with single quotes, double quotes, or just put it in by itself."
    echo " GOOD)% getunicode4char '\ '"
    echo ' GOOD)% getunicode4char "\ "'
    echo "      % #  This next one needs explaining. You should push the"
    echo "      % #+ Space Bar once after the backslash and then press the"
    echo "      % #+ Enter key."
    echo " GOOD)% getunicode4char \ "
    echo "--BAD)% getunicode4char ' '"
    echo '--BAD)% getunicode4char " "'
    echo
    echo "If you really want to use double quotes, watch out for the"
    echo "following, which will not allow the program to continue -"
    echo "i.e. they will break the program."
    echo "--BAD)% getunicode4char \"\\\""
    echo " instead, use single quotes or"
    echo " GOOD)% getunicode4char \"\\\\\""
    echo "--BAD)% getunicode4char \"\`\""
    echo " instead, use single quotes or"
    echo " GOOD)% getunicode4char \"\\\`\""
    echo "--BAD)% getunicode4char \"\"\""
    echo " instead, use single quotes or"
    echo " GOOD)% getunicode4char \"\\\"\""
  elif [ "$@" = "'" ]; then
    echo "U+0022"
  elif [ "$@" = "\"" ]; then
    echo "U+0028"
  elif [ "$@" = "\\" ]; then
    echo "U+005c"
  else
    python3_is_installed=0
    command -v python3 >/dev/null 2>&1 && python3_is_installed=1
    if [ $python3_is_installed -eq 1 ]; then
      zeroX_str=$(python3 -c 'print(hex(ord('"'$@'"')))')
      hex_only_str=$(echo "${zeroX_str}" | sed 's#0x##g')
      while [ ${#hex_only_str} -lt 4 ]; do
        hex_only_str="0${hex_only_str}"
      done ##endof:  while [ ${#hex_only_str} -lt 4 ]
      echo "U+${hex_only_str}"
      # Only returns unicode codepoints
    else
      echo "won't work for now. need python3"
      return -1
      #printf $@ | hexdump -C | head -n 1 | \
      # awk '{$1=""; $NF=""; print $0}' | \
      # sed 's#^[ ]\(.*\)[ ]\+$#0x\1#g; s#[ ]# 0x#g;'
    fi
  fi
  return 0
} ##endof:  getunicode4char()
   
## DWB
getbytes4unicode()
{
  if [ "$@" = "-h" -o "$@" = "--help" ]; then
    echo "Help for getbytes4unicode:"
    echo
    echo "Get the binary value for the bytes representing the"
    echo "character given as a unicode codepoint input."
    echo
    echo "Usage:"
    echo "% getbytes4unicode <string-with-only-hex-from-unicode-codepoint>"
    echo
    echo "Examples:"
    echo "% getbytes4unicode <string-with-only-hex-from-unicode-codepoint>"
  else
    codepoint_str="$@"
    to_print_str="\\U${codepoint_str}"
    while [ $(echo "${#cpdepoint_str} % 4" | bc) -ne 0 ]; do
      codepoint_str="0${codepoint_str}"
    done ##endof:  while [ $(echo "${#codepoint_str} % 4" | bc) -ne 0 ]
    if [ ${#codepoint_str} -eq 4 ]; then
      to_print_str="\\u${codepoint_str}"
    elif [ ${#codepoint_str} -eq 8 ]; then
      to_print_str="\\U${codepoint_str}"
    else
      echo "A maximum of 8 hex digits is allowed."
    fi
    printf ${to_print_str} | hexdump -C | head -n 1 | \
            awk '{$1=""; $NF=""; print $0}' | \
            sed 's#^[ ]\(.*\)[ ]\+$#0x\1#g; s#[ ]# 0x#g;'
  fi
} ##endof:  getbytes4unicode()

##DWB added 2025-07-29
get2byteandunicode4char()
{
  if [ "$@" = "-h" -o "$@" = "--help" ]; then
    echo "Help for get2bytesandunicode4char:"
    echo
    echo "Get the UTF-8 byte encoding for the "
    echo "character given as a unicode codepoint input."
    echo
    echo "Usage:"
    echo "% getbytes4unicode <string-with-only-one_char>"
    echo
    echo "Examples:"
    echo "% getbytes4unicode 'π'"
    echo
    echo "You can get more details on valid input from the help for"
    echo "getbytes4char, which is done with the command,"
    echo "% getbytes4char --help"
  else
    this_char=$@;
    first=$(gethex4char ${this_char} | tr -d '\n')
    second=$(getunicode4char ${this_char} | tr -d '\n')
    echo "( ${first} || ${second} )"
  fi
} ##endof:  get2byteandunicode4char()

alias get2bu4char='get2byteandunicode4char'
alias get24char='get2byteandunicode4char'

####################################
### More recent, small functions
####################################

##DWB: an easy way to add variable checking by useing another
##     shell, allowing use in any script or command
##@author: David Wallace BLACK
vardebug()
{
  echo "echo \"$@: \${$@}\""
  echo "   OR"
  echo "echo -e \"$@:\n\${$@}\""
  return 0
}

## DWB
## Used to get lines between two numbers from a file
htbetween_func () {
  usage_str="\n Needs two positive integers. Ex.\n"\
"\$ htbetween_func 4 72\n\n"\
" Usually used from the command line with, e.g.\n"\
" (User wants to get lines from count.txt between 4 and 72)\n"\
"\$ seq 1 100 > count.txt\n\$ htbstr 4 72\n"\
"head -n 72 | tail -69\n\$ cat -n count.txt | head -n 72 | tail -69\n\n"\
" Won't work as expected if the larger number is greater than the\n"\
" total number of lines.\n 'htbstr -h' returns this usage info\n"
  do_continue=1
  [ "$1" = "-h" ] && do_continue=0
  [ $# -lt 2 ] && do_continue=0
  if [ $do_continue -eq 1 ]; then
    [ "$1" -eq "$1" -a $1 -gt 0 ] 2>/dev/null || do_continue=0
  fi
  if [ $do_continue -eq 1 ]; then
    [ "$2" -eq "$2" -a $2 -gt 0 ] 2>/dev/null || do_continue=0
  fi

  [ $do_continue -eq 0 ] && echo -e "${usage_str}"
  if [ $do_continue -eq 1 ]; then
    first="$1"
    second="$2"
    greater=$first
    lesser=$second
    if [ $first -lt $second ]; then
      greater=$second
      lesser=$first
    fi
    n_for_tail=$(echo "${greater}-${lesser}+1" | bc)
    echo "head -n ${greater} | tail -${n_for_tail}"
  fi ##endof:  if [ $do_continue -eq 1 ]
} ##endof:  htbetween_func ()

alias htbstr=htbetween_func


## DWB 2020-05-26, Epoch: around 1590519675
git_trace_cmd_func() {
  echo "These are the commands to have git do a trace/strace-type"
  echo "thing during this terminal session (use without comments)"
  echo
  echo "-----------------------------------------"
  echo "# export GIT_TRACE_PACKET=1"
  echo "# export GIT_TRACE=1"
  echo "# export GIT_CURL_VERBOSE=1"
  echo "-----------------------------------------"
  echo
  echo "To get things back to normal during my session, I just"
  echo "change the instances of '1' to instances of '0', but "
  echo "some kind of 'unset' would also work."
  echo
} ##endof:  git_trace_cmd_func()

alias gittracecmd=git_trace_cmd_func
alias gittracecommand=git_trace_cmd_func


#  FIRST definewithheredoc FUNCTION DEF, NOT THE ONE THAT'S USED, NOW,
#+ ( 2025-10-17 )
#+ BUT THIS ONE HAS BETTER IN-FILE DOCUMENTATION
# @TODO: check
## DWB put in 2022-01-18, taken from
##+ https://stackoverflow.com/a/8088167/6505499
##+ defining a variable using a heredoc.
## Note that the alias, 'dhd', may be used
##+ everywhere you see 'definewithheredoc'
##+ below.
##
## More documentation is in the heredoc after the
## function definition.
#
definewithheredoc(){ IFS=$'\n' read -r -d '' ${1} || true; }
alias dhd='definewithheredoc'

### DWB 2022-01-18  I am giving the help for this heredoc-based function
##+ using the _same_ heredoc function. Metaaaaaa.
dhd HELPDOC <<'EndOfHelpDHD' | sed 's#^[.]$##g'
.

definewithheredoc

   DWB put this in here  2022-01-18, taken from
   https://stackoverflow.com/a/8088167/6505499
   defining a variable using a heredoc.

Note that the alias, 'dhd', may be used
everywhere you see 'definewithheredoc'
below.


USAGE

definewithheredoc VARIABLE_NAME <<LIMIT_STRING
<possibly several lines of text with no need for escapes>
lines
of
text
LIMIT_STRING

Some common choices for LIMIT_STRING include:
  EOF  ,  EOT  ,  EOM  ,  EndOfMessage

I will give two sets of commands; all the members of each
set are synonymous. See the example commands in the
EXAMPLE USAGE section below for an idea of what each does.
You can also consult
https://tldp.org/LDP/abs/html/here-docs.html

Each command (several lines of typed text with every new
line available via [ENTER]) should be entered at the
terminal prompt.


<set1>
#1.1
definewithheredoc MYVAR <<EOM
lines of
text and stuff
EOM

#1.2
dhd MYVAR <<EOM
lines of
text and stuff
EOM

</set1>


<set2>
#2.1
dhd OTHERVAR <<'EOM'
other 'lines' with
"characters" in #them
EOM

#2.2
dhd OTHERVAR <<"EOM"
other 'lines' with
"characters" in #them
EOM

#2.3
definewithheredoc OTHERVAR << \EOM
other 'lines' with
"characters" in #them
EOM

#2.4
definewithheredoc OTHERVAR <<"EOM"
other 'lines' with
"characters" in #them
EOM

#2.5
dhd OTHERVAR <<"NEVERMORE"
other 'lines' with
"characters" in #them
NEVERMORE

</set2>


EXAMPLE USAGE

$ # with expansion of command
$ definewithheredoc VAR1 <<EOF
abc'asdf"
$(echo "this-was-executed")
&*@!!++=
foo"bar"''
EOF
$ echo "$VAR1"
abc'asdf"
this-was-executed
foo"bar"''
$


OR (one other example with the EOF being different, see
....the StackOverflow reference above for more info)

$ # with command not expanded
$ definewithheredoc VAR2 <<'EOF'
abc'asdf"
$(dont-execute-this)
&*@!!++=
foo"bar"''
EOF
$ echo "$VAR2"
abc'asdf"
$(dont-execute-this)
&*@!!++=
foo"bar"''
$


NOTE: We always need the double quotes around whatever
      was used for VARIABLE_NAME when echoing the
      heredoc string variable. We did this with
        `echo "$VAR1"` and `echo "$VAR2"`
      in the examples.

.

EndOfHelpDHD

alias help_definewithheredoc='echo "$HELPDOC"'
alias help_dhd='help_definewithheredoc'


#  FIRST diffwithcontrol FUNCTION DEF, NOT THE ONE THAT'S USED, NOW
#+ ( 2025-10-17 )
#+ any differences now -^- unknown
#+ @TODO: check
diffwithcontrol()
{
  dhd dwc_help_str <<'EndOfDWC' | sed 's#^[.]$##g'
.
HELP FOR:
 diffwithcontrol

@AUTHOR
 David Wallace BLACK
GitHub: @bballdave025

@SINCE
 2022-03-09

@DESCRIPTION
 This will give a diff of two files, but will include any control
 characters that are in the files' content. It won't contain the
 `$' at the end of a line.
 This should be especially useful for files where `sed' commands
 are used to take out certain control characters.
 It's inspired by my `catwithcontrol' alias.

@USAGE
 % diffwithcontrol FILE1 FILE2

 Two arguments, no less and no more, should be given.

 If the `-h' or `--help' flag is used, this message will be
 outputted.

.
EndOfDWC

  if [ "$1" = "-h" -o "$2" -eq "--help" ]; then
    echo "${dwc_help_str}"
    return 1
  fi

  if [ $# -ne 2 ]; then
    echo "Exactly 2 arguments should be given." >&2
    echo "You gave %#"
    echo "${dwc_help_str}"
  fi

  first_file="$1"
  second_file="$2"

  diff "${first_file}" "${second_file}" | cat -ETv | \
    sed 's#[$]$##g;'

  return 0
} ##endof:  diffwithcontrol

alias dwc="diff_with_control"







# ---- Portable wrappers (no external deps) ----

# cat_with_control: show control chars (portable)
cat_with_control() 
{
  command -v cat >/dev/null || return 127; 
  cat -ETv -- "$@"; 
}
alias catwithcontrol='cat_with_control'

# atree: ASCII tree (portable if `tree` exists)
atree() 
{ if command -v tree >/dev/null; then 
    tree --charset=ascii "$@"; 
  else 
    echo "tree not installed"; 
    return 127; 
  fi; }

# atreea: like atree, but shows hidden files and directories, needs `tree`
atreea() 
{
  if command -v tree >/dev/null; then 
    tree --charset=ascii -a "$@"; 
  else 
    echo "tree not installed"; 
    return 127; 
  fi; 
} 


#  checksituation: friendly timestamp trio 
#+ and current working directory output
#+ (uses trpdate if present; else fallback)
checksituation() 
{
  echo "   Current date/tiime:"
  if type trpdate >/dev/null 2>&1; then trpdate
  else
    date; date +'%s'; date +'%s_%Y-%m-%dT%H%M%S%z'
  fi
  echo "   Current working directory:"
  pwd
}



# Color/ASCII sets — load if present; warn about grep+UTF-8 when relevant
set_color_command_aliases() {
  local f1="$HOME/.bballdave025_color4commands_set"
  if [ -f "$f1" ]; then . "$f1"; fi
  # Warn if grep may choke on non-UTF-8 locales
  if ! locale | grep -qi 'utf-8'; then
    echo "[warn] Non-UTF-8 locale detected; 'grep --color=auto' can mis-handle bytes." >&2
  fi
}
alias set_aliases_coco='set_color_command_aliases'
alias seta_coco='set_color_command_aliases'
alias sacoco='set_color_command_aliases'

# Main terminal aliases — placeholder; we’ll discuss grep unaliasing here later
set_main_terminal_aliases() {
  # @TODO: decide policy for `alias grep='grep --color=auto'` vs unalias.
  :
}
alias set_aliases_mt='set_main_terminal_aliases'
alias seta_mt='set_main_terminal_aliases'
alias samt='set_main_terminal_aliases'

# ---- Alias the function-runners when the functions exist ----
type git_branch_func        >/dev/null 2>&1 \
  && alias git_branch='git_branch_func'
type git_trace_cmd_func     >/dev/null 2>&1 \
  && alias gittracecmd='git_trace_cmd_func'
type git_trace_cmd_func     >/dev/null 2>&1 \
  && alias gittracecommand='git_trace_cmd_func'
type get2byteandunicode4char>/dev/null 2>&1 \
  && alias get2bu4char='get2byteandunicode4char'
type get2byteandunicode4char>/dev/null 2>&1 \
  && alias get24char='get2byteandunicode4char'
type definewithheredoc      >/dev/null 2>&1 \
  && alias dhd='definewithheredoc'
type help_definewithheredoc >/dev/null 2>&1 \
  && alias help_dhd='help_definewithheredoc'

#  cd_func is included even though it overrides the builtin `cd`
#+ to use the standard version, find it with  type cd, and use
#+ the absolute path
type cd_func >/dev/null 2>&1 && alias cd='cd_func'

# Provide $HELPDOC default text if unset (used by help_definewithheredoc)
: "${HELPDOC:=Portable help: definewithheredoc usage text not set.}"

# ---- Ubuntu test placeholders ----
# ## Place for set_title function

# ## Place for revert_title_path function

# ## Place for exts_in_dir function
# : '(consider replacing long alias with a function; TINN)'

# ---- Explicitly excluded for now ----
# htbetween_func
# xterm_double_wide xterm_std xterm_std_width_dbl_height  # (helps tmux)

###############################################################################

: "${strcleantermlog:=Portable terminal log cleanup placeholder.}"
alias forcleaningterminallog='echo "$strcleantermlog"'

# SECOND definewithheredoc FUNCTION DEF, THE ONE THAT'S USED, NOW
# @TODO: check
definewithheredoc ()
{
    IFS='
' read -r -d '' ${1} || true
}

# SECOND diffwithcontrol FUNCTION DEF, THE ONE THAT'S USED, NOW
#+ ( 2025-10-17 )
#+ any differences now -^- unknown
# @TODO: check
diffwithcontrol ()
{
    definewithheredoc dwc_help_str <<'EndOfDWC' | sed 's|^[.]$| |g'
.
HELP FOR:
 diffwithcontrol

@AUTHOR
 David Wallace BLACK
 GitHub @bballdave025

@SINCE
 2022-03-09

@DESCRIPTION
 This will give a diff of two files, but will include any control
 characters that are in the files' content. It won't contain the
 `$' at the end of a line.
 This should be especially useful for files where `sed' commands
 are used to take out certain control characters.
 It's inspired by my `catwithcontrol' alias.

@USAGE
 % diffwithcontrol FILE1 FILE2

 Two arguments, no less and no more, should be given.

 If the `-h' or `--help' flag is used, this message will be
 outputted.
.
EndOfDWC

    if [ "$1" = "-h" -o "$2" -eq "--help" ]; then
        echo "${dwc_help_str}";
        return 1;
    fi;
    if [ $# -ne 2 ]; then
        echo "Exactly 2 arguments should be given." 1>&2;
        echo "You gave %#";
        echo "${dwc_help_str}";
    fi;
    first_file="$1";
    second_file="$2";
    diff "${first_file}" "${second_file}" | cat -ETv | sed 's#[$]$##g;';
    return 0
}



# --- Grep policy: keep plain 'grep', use explicit helpers ---
unalias grep 2>/dev/null || true
alias grepcolor='grep --color=auto'
alias ugrep='grep --color=never'
alias bgrep='LC_ALL=C grep'
gcolor(){ case "$1" in on)alias grep='grep --color=auto';; off)unalias grep 2>/dev/null;; status|'')type -a grep;; *)echo "usage: gcolor {on|off|status} OR grepcolorset {on|off|status}";return 2;; esac; }
alias grepcolorset=gcolor

# --- ls policy: keep plain 'ls', use explicit helpers ---
unalias ls 2>/dev/null || true
alias lscolor='ls --color=auto'
alias uls='ls --color=never'
lcolor(){ case "$1" in on)alias ls='ls --color=auto';; off)unalias ls 2>/dev/null;; status|'')type -a ls;; *)echo "usage: lcolor {on|off|status} OR lscolorset {on|off|status}";return 2;; esac; }
alias lscolorset=lcolor

# --- egrep/fgrep helpers (keep commands plain) ---
unalias egrep 2>/dev/null || true
unalias fgrep 2>/dev/null || true
alias eg='grep -E'; alias fg='grep -F'
alias egcolor='grep -E --color=auto'; alias fgcolor='grep -F --color=auto'

# --- diff helpers ---
diffcolor(){ if diff --help 2>&1 | grep -q ' --color'; then command diff --color=auto "$@"; else command diff "$@"; fi; }
alias bdiff='LC_ALL=C diff'

# --- iproute2 color helper ---
ipcolor(){ command -v ip >/dev/null || { echo "ip not found" >&2; return 127; }; command ip -c "$@"; }


# --- runscriptreplayclean: interactive OR one-shot command logging ----------
# Usage:
#   runscriptreplayclean           #  full interactive session; exit to finish
#   runscriptreplayclean -l my.log            #  interactive; append to my.log
#   runscriptreplayclean -- <cmd args...>      #  one-shot command with 
#                                              #+ BEGIN/END markers
#   runscriptreplayclean -l my.log -- <cmd args...>
runscriptreplayclean() {
  local saved_in_dir="${HOME}/work_logs"
  local logfile="" cmd_str="" rc
  mkdir -p "$saved_in_dir"

  # Optional: -l/--log <file>
  if [[ "$1" == "-l" || "$1" == "--log" ]]; then
    logfile="$2"; shift 2
  fi

  # Default logfile
  if [[ -z "$logfile" ]]; then
    local ts; ts=$(ttdate 2>/dev/null || date +'%s_%Y-%m-%dT%H%M%S%z')
    logfile="${saved_in_dir}/Lab_Notebook_${USER}_${ts}.log"
  fi

  # --- MODE A: interactive whole-session logging (no BEGIN/END markers) -----
  if [[ "$1" != "--" ]]; then
    script -afe "$logfile"
    rc=$?
  else
    # --- MODE B: one-shot command with BEGIN/END markers in child shell ------
    shift
    # Safely quote the command line
    if [[ $# -eq 0 ]]; then
      echo "runscriptreplayclean: need command after --" >&2
      return 2
    fi
    local q= arg
    for arg in "$@"; do q+=" $(printf '%q' "$arg")"; done
    cmd_str="${q# }"

    # Run the command under a child bash, stamping BEGIN/END
    script -afe "$logfile" bash -lc \
'printf "[runlog] BEGIN %(%F %T %z)T\n" -1
trap '\''rc=$?; printf "[runlog] END rc=%s %(%F %T %z)T\n" "$rc" -1'\'' EXIT
'"$cmd_str"
    rc=$?
  fi
  
  # Make clean copy (ANSI escapes stripped) alongside the raw log
  
  ## -- simple regex-based cleaning --
  ##  If you prefer screen-hardcopy cleaning, comment out the next
  ##+ command and uncomment the screen block below.
  #sed -r $'s/\x1B\\[[0-9;]*[[:alpha:]]//g' "$logfile" \
  #            > "$clean" 2>/dev/null || cp -f "$logfile" "$clean"

  # -- screen-based cleaner (optional; may vary across distros) --
  #  If you prefer just the regex-based cleaning, comment out this
  #+ next command and uncomment the previous sed block
  if command -v screen >/dev/null 2>&1; then
    screen -D -m -c /dev/null sh -c \
"screen -X scrollback 500000; "\
"cat < \"$logfile\"; "\
"screen -X hardcopy -h \"$clean\"" \
    || sed -r $'s/\x1B\\[[0-9;]*[[:alpha:]]//g' "$logfile" > "$clean"
  fi

  printf "Raw log:   %s\nClean log: %s\n" "$logfile" "$clean"
  return "$rc"
}
# keep the muscle-memory alias
alias runlog='runscriptreplayclean'


# === verify_portable_bashrc: self-test =======================================
verify_portable_bashrc() {
  # Flags:
  #   -f <rcfile>   : path to the rc file (default: ~/vezde/.portable.bashrc)
  #   --quick       : skip isolated clean-shell source test
  #   --no-samples  : skip tiny sample runs (catwithcontrol/atree)
  #   --print       : print the names/arrays being checked and exit 0
  local rc="$HOME/vezde/.portable.bashrc"
  local QUICK=0 NOSAMPLES=0 PRINT=0
  while [ $# -gt 0 ]; do
    case "$1" in
      -f) rc="$2"; shift 2 ;;
      --quick) QUICK=1; shift ;;
      --no-samples) NOSAMPLES=1; shift ;;
      --print) PRINT=1; shift ;;
      *) echo \
"usage: verify_portable_bashrc [-f FILE] [--quick] [--no-samples] [--print]";
        return 2 
        ;;
    esac
  done

  # Core lists (must/optional)
  local -a MUST_ALIASES=(rmi cpi mvi lessraw whence grepcolor cgrep grepc ll la l dir vdir lsc lscolor lh ls_name_and_size runlog catwithcontrol atree checksituation dbldate tripledate ttdate)
  local -a OPT_ALIASES=(forcleaningterminallog git_branch gittracecmd gittracecommand get2bu4char get24char dhd help_dhd eg fg egcolor fgcolor ugrep bgrep gcolor diffcolor bdiff ipcolor)
  local -a MUST_FUNCS=(git_branch_func git_trace_cmd_func get2byteandunicode4char definewithheredoc cd_func)
  local -a OPT_FUNCS=(diff_with_control help_definewithheredoc)

  if [ "$PRINT" -eq 1 ]; then
    printf "RC: %s\n" "$rc"
    printf "MUST_ALIASES: %s\n" "${MUST_ALIASES[*]}"
    printf "OPT_ALIASES : %s\n" "${OPT_ALIASES[*]}"
    printf "MUST_FUNCS  : %s\n" "${MUST_FUNCS[*]}"
    printf "OPT_FUNCS   : %s\n" "${OPT_FUNCS[*]}"
    return 0
  fi

  echo "[verify] rc: $rc"
  local failures=0

  # 1) Syntax check
  if bash -n "$rc"; then
    echo "[verify] syntax: OK"
  else
    echo "[verify] syntax: FAIL"; failures=$((failures+1))
  fi

  # 2) Isolated clean-shell source test (unless --quick)
  if [ "$QUICK" -eq 0 ]; then
    if env -i HOME="$HOME" PATH="$PATH" \
                       bash --noprofile --norc -ic ". \"$rc\""; then
      echo "[verify] isolated source: OK"
    else
      echo "[verify] isolated source: FAIL"; failures=$((failures+1))
    fi
  else
    echo "[verify] isolated source: SKIP (--quick)"
  fi

  # 3) Presence checks
  local n t miss=0
  for n in "${MUST_ALIASES[@]}"; do
    t=$(type -t "$n" 2>/dev/null || true)
    if [ "$t" = "alias" ] || [ "$t" = "function" ]  || [ "$t" = "file" ] || [ "$t" = "builtin" ]; then
      printf "  OK alias/runner: %s\n" "$n"
    else
      printf "  MISSING alias/runner: %s\n" "$n"; miss=$((miss+1))
    fi
  done
  for n in "${MUST_FUNCS[@]}"; do
    t=$(type -t "$n" 2>/dev/null || true)
    if [ "$t" = "function" ]; then
      printf "  OK function: %s\n" "$n"
    else
      printf "  MISSING function: %s\n" "$n"; miss=$((miss+1))
    fi
  done
  # Optional sets (report but do not fail build)
  for n in "${OPT_ALIASES[@]}"; do
    t=$(type -t "$n" 2>/dev/null || true)
    if [ -n "$t" ]; then printf "  (opt) present: %s\n" "$n"; fi
  done
  for n in "${OPT_FUNCS[@]}"; do
    t=$(type -t "$n" 2>/dev/null || true)
    if [ "$t" = "function" ]; then 
      printf "  (opt) present: %s\n" "$n"; 
    fi
  done
  if [ "$miss" -gt 0 ]; then
    echo "[verify] presence: $miss missing (see lines above)"; 
    failures=$((failures+1))
  else
    echo "[verify] presence: OK"
  fi

  # 4) Tiny sample runs (skip with --no-samples)
  if [ "$NOSAMPLES" -eq 0 ]; then
    if type -t catwithcontrol >/dev/null 2>&1; then
      printf "A\tB\n" | catwithcontrol >/dev/null 2>&1 \
       && echo "  sample: catwithcontrol OK" \
       || { echo "  sample: catwithcontrol FAIL"; failures=$((failures+1)); }
    fi
    if command -v tree >/dev/null 2>&1 \
        && type -t atree >/dev/null 2>&1; then
      atree . >/dev/null 2>&1 \
        && echo "  sample: atree OK" \
        || { echo "  sample: atree FAIL"; failures=$((failures+1)); }
    else
      echo "  sample: atree SKIP (no tree or alias missing)"
    fi
  else
    echo "[verify] samples: SKIP (--no-samples)"
  fi

  # Summary/exit
  if [ "$failures" -eq 0 ]; then
    echo "[verify] ALL OK"
  else
    echo "[verify] $failures check(s) failed"
  fi
  return "$failures"
}
# ============================================================================ #
```


---------------------------------------------------------------------------













