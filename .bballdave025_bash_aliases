# .bballdave025_bash_aliases
#
#DWB 2022-02-26
#+ sourcing it from a new `.bash_aliases' file

## New runlog that includes script scrubbing (better method) in ~/.bashrc
## DWB 2025-07-21
#alias runlog="$HOME/run_script.sh"

alias catwithcontrol="cat -ETv"

alias atree='tree --charset=ascii'

alias checksituation='echo; echo " Current date/time is"; trpdate; '\
'echo; echo " Current directory ( pwd ) is "; pwd; echo;'

#eof err#set_command_color_aliases()
#eof err#{
#eof err#  this_help_str='
#eof err#
#eof err#
#eof err#Help for:
#eof err# set_command_color_aliases
#eof err#
#eof err#@AUTHOR : David Wallace BLACK
#eof err#           contact via email
#eof err#          uname: dblack         domain: captioncall   tld: com
#eof err#          uname: bballdave025   domain: yahoo         tld: com
#eof err#           Stack Exchange username @bballdave025
#eof err#
#eof err#@SINCE : 2022-03-02
#eof err#
#eof err#@DESCRIPTION
#eof err# Changes certain commands from the binary behavior to
#eof err#the often-Linux-flavor-default colorized behavior.
#eof err#Commands now changed are \`ls\' and \`grep\'.
#eof err#I prefer the binary by itself as a default, and I want
#eof err#to set and see any changes.
#eof err#
#eof err#@USAGE
#eof err# set_color_command_aliases
#eof err#
#eof err# The \`-h\' flag or the \`--help\' flag will return this message.
#eof err#
#eof err#
#eof err#'
#eof err#
#eof err#  if [ "$1" = "-h" -o "$1" = "--help" -o -z "$1" ]; then
#eof err#    echo $this_help_str
#eof err#
#eof err#    echo "with double quotes"
#eof err#    echo "$this_help_str"
#eof err#  fi
#eof err#
#eof err#  source "$HOME/.bballdave025_color4commands_set"
#eof err#
#eof err#} ##endof:  set_color_command_aliases

# Oh yeah, easier. ##DWB 2022-03-02
alias set_color_command_aliases='source "${HOME}/.bballdave025_color4commands_set"'

alias set_aliases_coco='set_color_command_aliases'
alias seta_coco='set_color_command_aliases'
alias sacoco='set_color_command_aliases'

#eof err#set_ascii_color_aliases()
#eof err#{
#eof err#  this_help_str='
#eof err#
#eof err#
#eof err#Help for:
#eof err# set_ascii_color_aliases
#eof err#
#eof err#@AUTHOR : David Wallace BLACK
#eof err#           contact via email
#eof err#          uname: dblack         domain: captioncall   tld: com
#eof err#          uname: bballdave025   domain: yahoo         tld: com
#eof err#           Stack Exchange username @bballdave025
#eof err#
#eof err#@SINCE : 2022-03-02
#eof err#
#eof err#@DESCRIPTION
#eof err# Gives what look like constants which can be used to
#eof err#change text color. Note that things must be used so
#eof err#that the shell expands escapes. For example, you
#eof err#could use
#eof err#
#eof err# $ echo -e \"Look, some ${ASCII_RED}colored${ASCII_NOCOLOR} text\"
#eof err#
#eof err#but not \`echo\' by itself. \`printf\' would work by
#eof err#itself, however. The following would not work.
#eof err#
#eof err# $ echo -e \
#eof err#\'You will not see any ${ASCII_BLUE}colors${ASCII_NOCOLOR} here\'
#eof err#
#eof err#@USAGE
#eof err# set_ascii_color_aliases
#eof err#
#eof err# The \`-h\' flag or the \`--help\' flag will return this message.
#eof err#
#eof err#
#eof err#'
#eof err#
#eof err#  if [ "$1" = "-h" -o "$1" = "--help" -o -z "$1" ]; then
#eof err#    echo $this_help_str
#eof err#
#eof err#    echo "with double quotes"
#eof err#    echo "$this_elp_str"
#eof err#  fi
#eof err#
#eof err#  source "$HOME/.bballdave025_ascii_color_aliases_set"
#eof err#
#eof err#} ##endof:  set_ascii_color_aliases

# Oh yeah, easier. ##DWB 2022-03-02
alias set_ascii_color_aliases='source "${HOME}/.bballdave025_ascii_color_aliases_set"'

alias set_aliases_asco='set_ascii_color_aliases'
alias seta_asco='set_ascii_color_aliases'
alias saasco='set_ascii_color_aliases'

alias set_main_terminal_aliases=\
'source "${HOME}/.bballdave025_main_terminal_aliases_set"'

alias set_aliases_mt='set_main_terminal_aliases'
alias seta_mt='set_main_terminal_aliases'
alias samt='set_main_terminal_aliases'


#alias whereispythonstuff='find /usr/lib/ '\
#'/cygdrive/c/Users/$USER/AppData/Local/Programs/Python/ '\
#'/cygdrive/c/Program\ Files/Python/ '\
#'/cygdrive/c/Program\ Files\ \(x86\)/Python/ '\
#'-mindepth 1 -maxdepth 1 -type d '\
#'-name "*[Pp]ython[0-9]*[0-9]*" 2>/dev/null'


#### DWB 2022-02-02 Let's put the long one in the middle
## DWB 2020-05-29 - 2020-05-30 (designed before)
## Gets all extensions, meaning both
##   1) everything in the bare filename after the first dot ('.')
##   2) only what's after the last dot in the bare filename
alias extsindir="ts=\$(date +'%s'); echo \"Finding extensions in\"; "\
"echo \" \$(pwd) \"; echo \"AT\"; date && date +'%s'; "\
"find . -type f -print0 | "\
"  xargs -I'{}' -0 "\
"    bash -c 'orig=\"{}\"; "\
"      find_two_dots=\$(echo \"\${orig}\" | "\
"                        grep \"^[.].*[.].*\$\"); "\
"      if [ ! -z \"\${find_two_dots}\" ]; then "\
"        this_ext=\$(echo \"\${orig}\" | "\
"          awk -F '\"'\"'/'\"'\"' '\"'\"'{print \$NF}'\"'\"' | "\
"          awk -F '\"'\"'.'\"'\"' "\
"                 '\"'\"'BEGIN{OFS=\".\"} {\$1=\"\"; print \$0}'\"'\"' | "\
"          tr -d \" \"); "\
"      fi; "\
"echo \"\${this_ext}\";' | "\
"  sort | uniq -c | sort -rn > "\
"    exts_in_\$(pwd | awk -F'/' '{print \$NF}')_\${ts}.lst && "\
"  awk -F'.' '{print \$NF}' "\
"         exts_in_\$(pwd | awk -F'/' '{print \$NF'})_\${ts}.lst | "\
"          sort -u > last_exts_\$(pwd | awk -F'/' '{print \$NF'})_\${ts}.lst;"\
"  echo \"Finished finding at\"; date && date +'%s'; "\
"  echo; "\
"  echo -e \" Full extension list in the file:\"; "\
"  echo \"exts_in_\$(pwd | awk -F'/' '{print \$NF}')_\${ts}.lst\"; "\
"  echo \" After the last dot extensions in the file:\"; "\
"  echo \"last_exts_\$(pwd | awk -F'/' '{print \$NF}')_\${ts}.lst\"; "

#############
# date stuff
alias dbldate="date && date +'%s'"
alias tripledate="date && date +'%s' && date +'%s_%Y-%m-%dT%H%M%S%z'"
alias trpdate=tripledate
alias oldtripledate="date && date +'%s' && date +'%s_%Y%m%dT%H%M%S%z'"
alias otrpdate=oldtripledate
alias tsdate="date +'%s'"
alias oldformatdatestr="echo '%Y%m%dT%H%M%S%z'"
alias ofdatecmd="echo \"date +'%Y%m%dT%H%M%S%z'\""
alias ofdate="date +'%Y%m%dT%H%M%S'"
alias ttdate="date +'%s_%Y-%m-%dT%H%M%S%z'"
alias oldttdate="date +'%s_%Y%m%dT%H%M%S%z'"
alias ottdate=oldttdate


################################
# xterm stuff, including sizes
# ref="https://unix.stackexchange.com/a/269553/291375" # for offset
# Remember an extra character vertically for the tmux info stuff, one
#+ for the separating line,
#+ and an extra character horizontally for the middle separating line
alias xterm_double_wide='dw_width=161; dw_height=47; '\
'                        dw_xoffset=20; dw_yoffset=15; '\
'uxterm -geometry ${dw_width}x${dw_height}+${dw_xoffset}+${dw_yoffset}'

# Note the standard 80x24 with one status line (in this case, for tmux), cf.
#+ ref1="https://softwareengineering.stackexchange.com/a/148765/319033"
#+ ref2="https://softwareengineering.stackexchange.com/questions/"\
#+"148754/why-is-24-lines-a-common-default-terminal-height"\
#+"#comment677689_148754"
#+ ref3="https://softwareengineering.stackexchange.com/a/148678/319033"
alias xterm_std='std_width=80; std_height=25; '\
'                std_xoffset=400; std_yoffset=350; '\
'uxterm -geometry ${std_width}x${std_height}+${std_xoffset}+${std_yoffset}'

alias xterm_std_width_dbl_height='swdh_width=80; swdh_height=455555; '\
'                                 swdh_xoffset=175; swdh_yoffset=500; '\
'uxterm -geometry ${swdh_width}x${swdh_height}+${swdh_xoffset}+${swdh_yoffset}'

alias xterm_std_height_dbl_width='shdw_width=161; shdw_height=25; '\
'                                 shdw_xoffset=100; shdw_yoffset=100; '\
'uxterm -geometry ${shdw_width}x${shdw_height}+${shdw_xoffset}+${shdw_yoffset}'

# top focus
# standard width, but can do something
# <------   (80)  ------>
# =======================     (1)        (1)  =======================
# .---------------------. -^- (1)        (1)  .---------------------.
# |                     |  |                  |                     |
# |                     |  |                  |                     |
# |                     | (28)          (28)  |                     |
# |                     |  |                  |                     |
# |                     |  |                  |                     |
# :---------------------: --- (1)   OR   (1)  :---------------------:  etc.
# |          |          |  |             (7)  |          |          |
# |          |          | (15)           (1)  :----------|----------|
# |          |          |  |             (7)  |          |          |
# '---------------------' -v- (1)        (1)  '---------------------'
#                        total  = (47) =  total
# -ish
#
alias xterm_top_focus='tpfc_width=80; tpfc_height=47; '\
'                                 tpfc_xoffset=200; tpfc_yoffset=25; '\
'uxterm -geometry ${tpfc_width}x${tpfc_height}+${tpfc_xoffset}+${tpfc_yoffset}'


alias xtdblw='xterm_double_wide'
alias xtstnd='xterm_std'
alias xtswdh='xterm_std_width_dbl_height'
alias xtshdw='xterm_std_height_dbl_width'
alias xttpfc='xterm_top_focus'


###############################################################
# TMUX session stuff - starting with just info  DWB 2022-03-30
#
# From the command line, I had:
# tmux list-panes -aF '\\n::Session: #{session_id} , #{session_name} , atta
#ched=#{session_attached}\\n:: Window: #{window_id} , #{window_name} , #{wi
#ndow_width}x#{window_height} , active=#{window_active}\\n:: Pane: #{pane_i
#d} , #{pane_name} , #{pane_title}, #{pane_width}x#{pane_height} , active=#
#{pane_active}\\n' | xargs -I'{}' echo -e "{}" ; echo
# Where I've split in the middle of words, etc. to note it all went on one
#+ long line. It would have been too long. I had lots of trouble trying to
#+ get it into an alias-able format.)
alias tmux_all_info='\
tmux list-panes -aF '"'"'
\\n::Session: #{session_id} , #{session_name} , '\
'attached=#{session_attached}\
:: Window: #{window_id} , #{window_name} , '\
'#{window_width}x#{window_height} , active=#{window_active}\
::   Pane: #{pane_id} , #{pane_name} , #{pane_title}, '\
'#{pane_width}x#{pane_height} , active=#{pane_active}'"'"' | \
  xargs -I'"'"'{}'"'"' echo -e "{}" ; echo; trpdate; echo;'
alias tmux_tai='tmux_all_info'


# For FHTW / Manuscript Reuse / other-names
alias classifyreuse3s='\(_\(\orc\|ucr\|spr\|fmr\|obr\|cwa\|tbr\|scg\|abg\|wpr\|gni\|mcl\|mbr\|mmx\|fko\|iac\|nbr\|oic\|noi\|dnu)\)'



## Get the timestamp at the end of a command even if exited no-zero
#  Imperfect way of checking the exit status of a command as
#+ well as knowing when it ended (for things such as timing
#+ commands when `time <command>` isn't an option).
#+ I'm find with a double timestamp

#  WAY 1 (LOSES THE SIGNIFICANCE OF FIRST RETURN-CODE MESSAGE,
#+ BUT WILL FAIL LESS OFTEN, I.E. IT CAN BE RUN BY ITSELF ...
#+ WHICH IS REALLY USELESS, BUT WHATEVER)
alias ttdatechk=' : && echo -e "$(ttdate)\nExitedNormally"     '\
'                  '\
'                   || echo -e "$(ttdate)\nExitedNonZero"     '\
'          '\
'; ttdate; echo "  (this may be a BONUS timestamp)";                   '\
'          '\
'#  '"'"'; ttdate'"'"' -> Make sure we get the timestamp '\
'even if something     '\
'          '\
'#+ weird makes us bypass the && and || after the                      '\
'          '\
'#+ command we are checking, something like                            '\
'          '\
'#+   some_error_command && run_main_checked_thing && ttdatechk        '\
'          '\
'#+ (though that doesn'"'"'t make it bypass                            '\
'    '\
'          '\
'#+ the short-circuit &&, ||)                                          '\
'          '\
'#+ Note I don'"'"'t care about a double                               '\
'    '\
'          '\
'#+ timestamp, as long as I get at least one.                          '\
'          '\
'#                                                                     '\
'          '\
'#+ To see how it works, use the commands,                             '\
'          '\
'#+ % awk 2>/dev/null && whoami && ttdatechk  # no whoami output       '\
'          '\
'#+ % echo "Will you see who you are?" && whoami && ttdatechk          '\
'          '\
'#                                                                     '\
'          '\
'#  Comments formatted for `type ttdatechk` with                       '\
'          '\
'#+ an 80-character-width terminal                                     '\
'          '\
'#+ Trailing single quote matches the backtick after "aliased to "'

#  WAY 2 (GIVES SIGNIFICANT RETURN VALUE INTERPRETATION)
#+ NEEDS TO BE PRECEDED BY AN  &&  (AS I USE IT)
alias ttdatechk='      echo -e "$(ttdate)\nExitedNormally"     '\
'                  '\
'                   || echo -e "$(ttdate)\nExitedNonZero"     '\
'          '\
'; ttdate; echo "  (this may be a BONUS timestamp)";                   '\
'          '\
'#  '"'"'; ttdate'"'"' -> Make sure we get the timestamp '\
'even if something     '\
'          '\
'#+ weird makes us bypass the && and || after the                      '\
'          '\
'#+ command we are checking, something like                            '\
'          '\
'#+   some_error_command && run_main_checked_thing && ttdatechk        '\
'          '\
'#+ (though that doesn'"'"'t make it bypass                            '\
'    '\
'          '\
'#+ the short-circuit &&, ||)                                          '\
'          '\
'#+ Note I don'"'"'t care about a double                               '\
'    '\
'          '\
'#+ timestamp, as long as I get at least one.                          '\
'          '\
'#                                                                     '\
'          '\
'#+ To see how it works, use the commands,                             '\
'          '\
'#+ % awk 2>/dev/null && whoami && ttdatechk  # no whoami output       '\
'          '\
'#+ % echo "Will you see who you are?" && whoami && ttdatechk          '\
'          '\
'#                                                                     '\
'          '\
'#  Comments formatted for `type ttdatechk` with                       '\
'          '\
'#+ an 80-character-width terminal                                     '\
'          '\
'#+ Trailing single quote matches the backtick after "aliased to "'


## DWB, 2025-06-27, See commands and commentary for checking filenames
IFS='\n' read -r -d '' str4fnameregexcheck <<'EndofRegExInfo'

######### COMMANDS CAN BE COPY/PASTED, OR YOU CAN USE THE IDEAS #########
######### TO GET WHAT YOU WANT. (DON'T INCLUDE LEADING $S)      #########

$ #
#  USE THIS MOST - combined for characters, non-ascii; 
#+ and characters, non-printable ascii--includes space,
#+ tab, carriage return, linefeed
# @@@@@@@@@@@@@@@@@@@@ IMPORTANT CHECK 1 @@@@@@@@@@@@@@@@@@@@
$ find . -type f | awk -F'/' '{print $NF}' |
    LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | wc -l
$ # @@@@@@@@@
$ ##### Possible subsets if desired #####
$ ##      - Any with non-printable ASCII (definitely control chars)
    $ find . -type f | awk -F'/' '{print $NF}' | 
        LC_ALL=C grep -oP "[\x00-\x08\x0B-\x0C\x0E-\x1F\x7F]" | wc -l
$ #
#  Any with undesired space-y (still 'printable' in that they show
#+ up, but control-y), tab, line feed, carriage return, space
#+ ( I don't include:
#+        VERTICAL TAB  -  \x0B , \013 ;
#+   or   FORM FEED     -  \x0C , \014 ;
#+   I guess they're technically in the same group, but I don't
#+   run into them nearly as often, so I put them in the
#+   general control character group.)
    $ find . -type f | awk -F'/' '{print $NF}' | 
        LC_ALL=C grep -oP "[\x09-\x10\x0B\x0D\x20]" | wc -l
$ ##### Any that are actually non-ASCII? #####
    $ find . -type f | awk -F'/' '{print $NF}' | 
        Do LC_ALL=C grep -oP "[\x80-\xFF]" | wc -l
$ #  Do LC_ALL=C we have any filenames with undesired
$ #+ ASCII characters (Dave's no-nos)
$ # So, to find out if any filenames have those unwanted characters
$ # @@@@@@@@@@@@@@@@@@@@ IMPORTANT CHECK 2 @@@@@@@@@@@@@@@@@@@@
$ find . -type f | awk -F'/' '{print $NF}' | 
    LC_ALL=C grep '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']' | wc -l
$ # @@@@@@@@@


#  This is as good a place as any to put these next notes, which
#+ are useful for fixing the new replay cleaning of runscript results
#+ Note to WATCH OUT for false positives when joining lines that
#+ got cut by the right side of the terminal. 
#+ The right-side-of-the-terminal thing is why we have a series of
#+ regexes having multiples of 80. If the terminal width has been
#+ changed, the regexes will need to change in order to match the
#+ width. The width can be found with   tput cols
## (Cleaning still not perfect, but better now than before. I'm pretty
#+ sure the problem is specific to Cygwin but haven't tested.)
#
#  The series of regexes is specifically for Notepad++ and has a few
#+ quirks specific to that program. There shouldn't be any spaces.

   Srch:   ^(.{80})\n(.+)$      Repl:   \1\2
   Srch:   ^(.{160})\n(.+)$     Repl:   \1\2

# and so forth with 240, 320, ... if needed. 


#  For when copy/paste from Cygwin terminal puts spaces up to 80
#+ (more accurately, `$(tput cols)') characters instead of using
#+ a linefeed character.
#+ Notepad++ RegEx (not perfect with 80 characters), but can find
#+ them)
   Srch:   ^([$].+[ ]{10,})([^ ]+.*)$

#########################################################################
EndofRegExInfo

export str4fnameregexcheck

alias commandsforcheckingfilenames='echo "${str4fnameregexcheck}"'
alias cfcf=commandsforcheckingfilenames
alias cmds4checkfnames=cfcf
alias cfsquared=cfcf
alias c4cf=cfcf



## DWB, 2025-08-25, TL;DR commands and commentary for checking filenames
IFS='\n' read -r -d '' str4cfcfquick <<'EndofQuickRegExInfo'
#                                                                       #
######### COMMANDS CAN BE COPY/PASTED, OR YOU CAN USE THE IDEAS #########
######### TO GET WHAT YOU WANT. (DON'T INCLUDE LEADING $S)      #########

#  USE THIS MOST - Find characters that are non-ascii; 
#+ Find characters that are non-printable ascii - includes 
#+ space, tab, carriage return, linefeed
#+
# @@@@@@@@@@@@@@@@@@@@ IMPORTANT CHECK 1 @@@@@@@@@@@@@@@@@@@@

$ find . -type f | awk -F'/' '{print $NF}' |
    LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | wc -l

# @@@@@@@@@


#  Do we have any filenames with undesired ASCII
#+ characters (Dave's no-nos, which are the characters
#+ he has found to cause problems in later parsing.)
#+
# @@@@@@@@@@@@@@@@@@@@ IMPORTANT CHECK 2 @@@@@@@@@@@@@@@@@@@@

$ find . -type f | awk -F'/' '{print $NF}' | 
    LC_ALL=C grep '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']' | wc -l

# @@@@@@@@@

#########################################################################
EndofQuickRegExInfo

export str4cfcfquick

alias commandsforcheckingfilenamesquick='echo "${str4cfcfquick}"'
alias cfcfq=commandsforcheckingfilenamesquick
alias cfcfquick=commandsforcheckingfilenamesquick
alias cmds4checkfnamesquick=commandsforcheckingfilenamesquick
alias cfsquaredquick=commandsforcheckingfilenamesquick
alias c4cfquick=commandsforcheckingfilenamesquick
alias c4cfq=commandsforcheckingfilenamesquick
alias cfcftldr=commandsforcheckingfilenamesquick


## DWB, 2025-08-25, specifics for cleaning terminal logs in Notepad++
IFS='\n' read -r -d '' strcleantermlog <<'EndofCleanTermLog'
#                                                                       #
######### COMMANDS CAN BE COPY/PASTED, OR YOU CAN USE THE IDEAS #########
######### TO GET WHAT YOU WANT.                                 #########

#  Useful when doing extra cleaning on terminal I/O
#+ logs (specific for when `tput cols' returns `80')
#+ I use them with Notepad++ regex Search&Replace
#+ There shouldn't be any spaces.
          Srch:   ^(.{80})\n(.+)$      Repl:   \1\2
          Srch:   ^(.{160})\n(.+)$     Repl:   \1\2
#+ and so forth with 240, 320, ... if needed. 

#  For when copy/paste from Cygwin terminal puts spaces up to
#+ the terminal width (though no reference to terminal width)
          Srch:   ^([$].+[ ]{10,})([^ ]+.*)$
#+ cf. my_unix_se="https://web.archive.org/web/20250825181356/"\
#+ "https://unix.stackexchange.com/questions/798737/regex-to-find-"\
#+ "text-plus-trailing-10-spaces-sum-of-two-matches-lengths-is-part" 

#########################################################################
EndofCleanTermLog

export strcleantermlog

alias forcleaningterminallog='echo "${strcleantermlog}"'
alias forcleantl=forcleaningterminallog



##################################################################
##     fhtw2025information3lettgroups
##       f25info     OR     f25groups
##                   OR     f25guide
##   
##  Guide to the FHTW-2025 class-group aliases
##+ The comments I've put before the alias definitions
##+ make up this information
## DWB, 2025-08-06
IFS='\n' read -r -d '' str4fhtw2025infoguide <<'EndofFHTW2025InfoGuide'
-----------------------------------------------------------------------
INFORMATION AND ALIASES FOR 3-LETTER CLASSIFICATION EQUIVALENCIES;
THE 3 LETTERS ARE PLACED AFTER THE BARE FILENAME, PREPENDED BY AN
UNDERSCORE.

Note that all reges are greppable BREs
For ERE or PCRE, use the command,
     $ echo $(<this_f25_alias>) | tr -n '\\'
a couple of e.g.s
     $ echo $(f25info) | tr -n '\\'
     $ echo $(f25a3) | tr -n '\\'
---
    fhtw2025information3lettgroups
      f25info     OR     f25groups
      f253lett    OR     f25guide
  
 Guide to the FHTW-2025 class-group aliases
 The comments I've put before the alias definitions
 make up this information
DWB, 2025-08-06
--------------
    fhtw2025all3lett
      f25a3
 Used classifications for FHTW-2025
--------------
    fhtw2025model3lett
      f25m3
 Classifications used by Reuse Model for FHTW 2025,
 These will have a model made for a binary classifier
--------------
    fhtw2025nomod3lett
      f25n3
 Classifications NOT used by Reuse Model for FHTW 2025,
 These will NOT have a model made for a binary classifier,
 but are here for analysis purposes.
 PLEASE NOTE that this doesn't mean no-reuse, it just
 means this classification won't have its own model.
--------------
    fhtw2025singletypepos3lett
      f25s3     OR     f25p3
  Classifications used by Reuse Model for FHTW 2025,
 but only those with single-type, positive reuse. 
 (Nota Bene that 'nbr' is actually the deciding 
  classification for the multi, yes_reuse vs. 
  no_reuse binary classification via
       yes_reuse=!{'nbr}'
  We have 'nbr' in f25m3, but not in this f25s3)
 I'm making two aliases to access this info
    f25s3    # mnemonic "single"
    f25p3    # mnemonic "positive
 These will have a model made for a single-type
  binary classifier
-----------------------------------------------------------------------
EndofFHTW2025InfoGuide

export str4fhtw2025infoguide

alias fhtw2025information3lettgroups='echo "${str4fhtw2025infoguide}"'
alias f25info='fhtw2025information3lettgroups'
alias f25guide='fhtw2025information3lettgroups'
alias f25groups='fhtw2025information3lettgroups'
alias f253lett='fhtw2025information3lettgroups'


##---------------------------------------------------------------------

##     fhtw2025all3lett
##       f25a3
##+ Used classifications for FHTW-2025
##+
##+ Greppable (BRE)
##+ For ERE or PCRE, use the result of 
##+   % echo $(f25a3) | tr -d '\\' 
alias fhtw2025all3lett='echo "\(abg\|cwa\|fko\|fmr\|gni\|iac\|'\
'mbr\|mcl\|mmx\|nbr\|oic\|orc\|scg\|spr\|suh\|tbr\|ucr\)";'
alias f25a3='fhtw2025all3lett'


##---------------------------------------------------------------------

##     fhtw2025model3lett
##       f25m3
##  Classifications used by Reuse Model for FHTW 2025,
##+ These will have a model made for a binary classifier
##+
##+ Greppable (BRE)
##+ For ERE or PCRE, use the result of 
##+   % echo $(f25m3) | tr -d '\\' 
alias fhtw2025model3lett=\
'echo "\(cwa\|fmr\|gni\|nbr\|orc\|scg\|spr\|tbr\|ucr\)"'
alias f25m3='fhtw2025model3lett'


##---------------------------------------------------------------------

##     fhtw2025nomod3lett
##       f25n3
##+ Classifications NOT used by Reuse Model for FHTW 2025,
##+ These will NOT have a model made for a binary classifier,
##+ but are here for analysis purposes.
##+ PLEASE NOTE that this doesn't mean no-reuse, it just
##+ means this classification won't have its own model.
##+ 
##+ Greppable (BRE)
##+ For ERE or PCRE, use the result of 
##+   % echo $(f25n3) | tr -d '\\' 
alias fhtw2025nomod3lett=\
'echo "\(abg\|fko\|iac\|mbr\|mcl\|mmx\|oic\|suh\)"'
alias f25n3='fhtw2025nomod3lett'


##---------------------------------------------------------------------

##     fhtw2025singletypepos3lett
##       f25s3     OR     f25p3
##+  Classifications used by Reuse Model for FHTW 2025,
##+ but only those with single-type, positive reuse. 
##+ (Nota Bene that 'nbr' is actually the deciding 
##+  classification for the multi, yes_reuse vs. 
##+  no_reuse binary classification via
##+       yes_reuse=!{'nbr}'
##+  We have 'nbr' in f25m3, but not in this f25s3)
##+ I'm making two aliases to access this info
##+    f25s3    # mnemonic "single"
##+    f25p3    # mnemonic "positive
##+ These will have a model made for a single-type
##+  binary classifier
##+
##+ greppable (BRE).
##+ For ERE or PCRE, use the result of 
##+   % echo $(f25p3) | tr -d '\\' 
alias fhtw2025singletypepos3lett=\
'echo "\(cwa\|fmr\|gni\|orc\|scg\|spr\|tbr\|ucr\)"'
alias f25s3='fhtw2025singletypepos3lett'
alias f25p3='fhtw2025singletypepos3lett'

